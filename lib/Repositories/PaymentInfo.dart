import 'package:cloud_firestore/cloud_firestore.dart';
import '../domains/PaymentInfo.dart'; // Assuming manage_payment_model.dart contains ManagePayment class

class PaymentInfo {
  final FirebaseFirestore _firestore;

  // Constructor allowing for dependency injection (useful for testing)
  PaymentInfo({FirebaseFirestore? firestore})
      : _firestore = firestore?? FirebaseFirestore.instance;

  // Private helper for the payments collection reference with a converter
  CollectionReference<ManagePayment> get _paymentsCollection =>
      _firestore.collection('payments').withConverter<ManagePayment>(
            fromFirestore: (snapshots, _) => ManagePayment.fromMap(snapshots.data()!, snapshots.id),
            toFirestore: (payment, _) => payment.toJson(),
          );

  // --- Read Operations (Client-Side Safe) ---

  // Read all payments for a specific user (real-time stream)
  Stream<List<ManagePayment>> getUserPayments(String userId) {
    return _paymentsCollection
       .where('userId', isEqualTo: userId)
       .orderBy('paymentDate', descending: true) // Example: order by date
       .snapshots()
       .map((snapshot) => snapshot.docs.map((doc) => doc.data()).toList());
  }

  // Read a single payment by its ID (real-time stream)
  Stream<ManagePayment?> getPaymentByIdStream(String paymentId) {
    return _paymentsCollection
       .doc(paymentId)
       .snapshots()
       .map((snapshot) => snapshot.exists? snapshot.data() : null);
  }

  // Read a single payment by its ID (one-time fetch)
  Future<ManagePayment?> getPaymentByIdFuture(String paymentId) async {
    final snapshot = await _paymentsCollection.doc(paymentId).get();
    return snapshot.exists? snapshot.data() : null;
  }


  // --- Write Operations (Illustrative - To Be Called from Backend/Cloud Functions) ---
  // The following methods illustrate Firestore API usage for writes.
  // Due to the security rules (disallowing client-side writes), these would
  // typically be invoked from a backend environment (e.g., Cloud Functions using Admin SDK)
  // or the client would call a Cloud Function that performs these operations.

  // Create a new payment document in Firestore
  // This would typically be part of a Cloud Function that also creates a Stripe PaymentIntent
  Future<String> createPaymentRecord(ManagePayment payment) async {
    // Note: In a real scenario, paymentId might be set by Firestore or come from Stripe.
    // If using Firestore's auto-ID, use.add() and get the ID from the DocumentReference.
    // For this example, assuming payment.paymentId is pre-determined or not the Firestore doc ID.
    // The.add() method is generally preferred for new documents to get auto-generated IDs.
    DocumentReference docRef = await _firestore.collection('payments').add(payment.toJson());
    return docRef.id; // Return the auto-generated Firestore document ID
  }

  // Update an existing payment document in Firestore
  // e.g., to change status, description, or amount (before payment processing)
  // or to update status and paymentDate after successful payment via Stripe (from a Cloud Function/Webhook)
  Future<void> updatePaymentRecord(String paymentId, Map<String, dynamic> data) async {
    // Ensure data includes a server timestamp if updating a date field from backend
    // e.g., data = FieldValue.serverTimestamp();
    await _firestore.collection('payments').doc(paymentId).update(data);
  }

  // Delete a payment document from Firestore
  Future<void> deletePaymentRecord(String paymentId) async {
    await _firestore.collection('payments').doc(paymentId).delete();
  }
  Future<String> createPendingPayment({
    required double amount,
    required String description,
    required String userId,
  }) async {
    // Create a new ManagePayment object with a pending status
    final newPayment = ManagePayment(
      paymentId: '', // ID will be generated by Firestore, so we leave this empty
      userId: userId,
      paymentAmount: amount,
      paymentDescription: description,
      paymentStatus: 'pending', // Always start as 'pending'
      paymentDate: null,
    );

    // Add the object to Firestore. Firestore will generate the ID.
    final docRef = await _firestore.collection('payments').add(newPayment.toJson());

    // Return the ID of the newly created document
    return docRef.id;
  }

  Future<ManagePayment?> getPaymentById(String paymentId) async {
    try {
      final docSnapshot =
          await _firestore.collection('payments').doc(paymentId).get();

      if (docSnapshot.exists) {
        // If the document exists, convert it to our ManagePayment object
        return ManagePayment.fromMap(
            docSnapshot.data()!, docSnapshot.id);
      } else {
        // If no document is found, return null
        return null;
      }
    } catch (e) {
      print('Error fetching payment by ID: $e');
      return null;
    }
  }

  Future<void> updatePaymentDetails(String paymentId, {
    required String description,
    required double amount,
  }) async {
    await _firestore.collection('payments').doc(paymentId).update({
      'paymentDescription': description,
      'paymentAmount': amount,
    });
  }

  // Updates the status of a payment and sets the completion date
  Future<void> updatePaymentStatus(String paymentId, String status) async {
    final updateData = <String, dynamic>{
      'paymentStatus': status,
    };

    // If the payment is successful, also record the exact time
    if (status == 'complete') {
      updateData['paymentDate'] = FieldValue.serverTimestamp();
    }

    await _firestore.collection('payments').doc(paymentId).update(updateData);
  }
}